package net.foxycorndog.jdoogl;

import static net.foxycorndog.jdoogl.GL.beginTextureDraw;
import static net.foxycorndog.jdoogl.GL.beginVertexDraw;
import static net.foxycorndog.jdoogl.GL.endTextureDraw;
import static net.foxycorndog.jdoogl.GL.endVertexDraw;
import static org.lwjgl.opengl.GL11.GL_ALPHA_TEST;
import static org.lwjgl.opengl.GL11.GL_AMBIENT_AND_DIFFUSE;
import static org.lwjgl.opengl.GL11.GL_BLEND;
import static org.lwjgl.opengl.GL11.GL_COLOR_MATERIAL;
import static org.lwjgl.opengl.GL11.GL_DEPTH_TEST;
import static org.lwjgl.opengl.GL11.GL_DIFFUSE;
import static org.lwjgl.opengl.GL11.GL_FLOAT;
import static org.lwjgl.opengl.GL11.GL_FRONT;
import static org.lwjgl.opengl.GL11.GL_GREATER;
import static org.lwjgl.opengl.GL11.GL_LEQUAL;
import static org.lwjgl.opengl.GL11.GL_LIGHT0;
import static org.lwjgl.opengl.GL11.GL_LIGHTING;
import static org.lwjgl.opengl.GL11.GL_LIGHT_MODEL_AMBIENT;
import static org.lwjgl.opengl.GL11.GL_MODELVIEW;
import static org.lwjgl.opengl.GL11.GL_NEAREST;
import static org.lwjgl.opengl.GL11.GL_NICEST;
import static org.lwjgl.opengl.GL11.GL_NORMAL_ARRAY;
import static org.lwjgl.opengl.GL11.GL_ONE;
import static org.lwjgl.opengl.GL11.GL_ONE_MINUS_SRC_ALPHA;
import static org.lwjgl.opengl.GL11.GL_PERSPECTIVE_CORRECTION_HINT;
import static org.lwjgl.opengl.GL11.GL_POSITION;
import static org.lwjgl.opengl.GL11.GL_PROJECTION;
import static org.lwjgl.opengl.GL11.GL_REPLACE;
import static org.lwjgl.opengl.GL11.GL_SHININESS;
import static org.lwjgl.opengl.GL11.GL_SMOOTH;
import static org.lwjgl.opengl.GL11.GL_SPECULAR;
import static org.lwjgl.opengl.GL11.GL_SRC_ALPHA;
import static org.lwjgl.opengl.GL11.GL_TEXTURE_2D;
import static org.lwjgl.opengl.GL11.GL_TEXTURE_COORD_ARRAY;
import static org.lwjgl.opengl.GL11.GL_OR_INVERTED;
import static org.lwjgl.opengl.GL11.GL_TEXTURE_ENV;
import static org.lwjgl.opengl.GL11.GL_TEXTURE_ENV_MODE;
import static org.lwjgl.opengl.GL11.glClearDepth;
import static org.lwjgl.opengl.GL11.glColorMaterial;
import static org.lwjgl.opengl.GL11.glDepthFunc;
import static org.lwjgl.opengl.GL11.glLight;
import static org.lwjgl.opengl.GL11.glLightModel;
import static org.lwjgl.opengl.GL11.glLogicOp;
import static org.lwjgl.opengl.GL11.GL_TEXTURE_MAG_FILTER;
import static org.lwjgl.opengl.GL11.GL_TEXTURE_MIN_FILTER;
import static org.lwjgl.opengl.GL11.GL_VERTEX_ARRAY;
import static org.lwjgl.opengl.GL11.glAlphaFunc;
import static org.lwjgl.opengl.GL11.glBlendFunc;
import static org.lwjgl.opengl.GL11.glClearColor;
import static org.lwjgl.opengl.GL11.glDisableClientState;
import static org.lwjgl.opengl.GL11.glEnable;
import static org.lwjgl.opengl.GL11.glDisable;
import static org.lwjgl.opengl.GL11.glIsEnabled;
import static org.lwjgl.opengl.GL11.glEnableClientState;
import static org.lwjgl.opengl.GL11.glHint;
import static org.lwjgl.opengl.GL11.glLoadIdentity;
import static org.lwjgl.opengl.GL11.glMaterial;
import static org.lwjgl.opengl.GL11.glMaterialf;
import static org.lwjgl.opengl.GL11.glMatrixMode;
import static org.lwjgl.opengl.GL11.glNormalPointer;
import static org.lwjgl.opengl.GL11.glRotatef;
import static org.lwjgl.opengl.GL11.glRotated;
import static org.lwjgl.opengl.GL11.glOrtho;
import static org.lwjgl.opengl.GL11.glShadeModel;
import static org.lwjgl.opengl.GL11.glScissor;
import static org.lwjgl.opengl.GL11.glTexCoordPointer;
import static org.lwjgl.opengl.GL11.glPushMatrix;
import static org.lwjgl.opengl.GL11.glPopMatrix;
import static org.lwjgl.opengl.GL11.glTexEnvf;
import static org.lwjgl.opengl.GL11.glTexParameteri;
import static org.lwjgl.opengl.GL11.glVertexPointer;
import static org.lwjgl.opengl.GL11.glViewport;
import static org.lwjgl.opengl.GL11.glTranslatef;
import static org.lwjgl.opengl.GL11.glTranslated;
import static org.lwjgl.opengl.GL11.GL_COLOR_LOGIC_OP;
import static org.lwjgl.opengl.GL11.glScalef;
//import static org.lwjgl.opengl.GL11.gl
import static org.lwjgl.opengl.GL11.glColor4f;
import static org.lwjgl.opengl.GL11.glScaled;
import static org.lwjgl.opengl.GL11.glDrawArrays;
import static org.lwjgl.opengl.GL11.GL_SCISSOR_TEST;
import static org.lwjgl.opengl.GL15.GL_ARRAY_BUFFER;
import static org.lwjgl.opengl.GL15.glBindBuffer;

import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.util.glu.GLU.gluPerspective;

import java.awt.Canvas;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.ArrayList;

import javax.imageio.ImageIO;
import javax.naming.OperationNotSupportedException;

import net.foxycorndog.jdobase.Base;
import net.foxycorndog.jdoogl.components.Frame;
import net.foxycorndog.jdoogl.geometry.Point;
import net.foxycorndog.jdoogl.geometry.Vector;
import net.foxycorndog.jdoogl.image.imagemap.ImageMap;
import net.foxycorndog.jdoogl.image.imagemap.SpriteSheet;
import net.foxycorndog.jdoogl.image.imagemap.Texture;
import net.foxycorndog.jdoutil.Buffer;
import net.foxycorndog.jdoutil.LightBuffer;
import net.foxycorndog.jdoutil.Task;
import net.foxycorndog.jdoutil.VerticesBuffer;
import net.foxycorndog.jdoutil.color.ColorUtil;

import org.lwjgl.BufferUtils;
import org.lwjgl.LWJGLException;
import org.lwjgl.input.Keyboard;
import org.lwjgl.openal.AL;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.DisplayMode;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL12;
import org.lwjgl.opengl.GL13;
import org.lwjgl.opengl.GL14;
import org.lwjgl.opengl.GL15;
import org.lwjgl.opengl.GL20;
import org.lwjgl.opengl.GL21;
import org.lwjgl.opengl.GL30;
import org.lwjgl.opengl.GL40;
import org.lwjgl.util.glu.GLU;

import de.matthiasmann.twl.utils.PNGDecoder;
import de.matthiasmann.twl.utils.PNGDecoder.Format;

/**
* Class used for accessing many static methods that incorporate
* OpenGL.
* 
* @author Braden Steffaniak
* @since  Fri May 25 10:29:08 AM
*/

public class GL
{
	private static boolean flipped;
	private static boolean render3D;
	private static boolean wireFrame, showColors;
	
	private static double offsets[]        = new double[3];
	private static double scale[]          = new double[] { 1, 1, 1 };
	private static double renderLocation[] = new double[] { 0, 0, 0 };
	
	private static float  ambientLight[];
	
	private static ArrayList<double[]> tempOffsets        = new ArrayList<double[]>();
	private static ArrayList<double[]> tempScale          = new ArrayList<double[]>();
	private static ArrayList<double[]> tempRenderLocation = new ArrayList<double[]>();
	
	public  static Texture     white;
	
	private static int	       rectVerticesPosition, rectTexturesPosition;
	
	private static float       zClose, zFar;
	private static float       FOV;
	
	private static ArrayList<LightBuffer> rectVerticesBuffer, rectTexturesBuffer;
	
	private static final String version = "0.5 Dev";
	
	public  static final int FILL = GL_FILL;
	
	/**
	 * All of the available lights.
	 */
	public static final int LIGHT0 = GL_LIGHT0, LIGHT1 = GL_LIGHT1, LIGHT2 = GL_LIGHT2, LIGHT3 = GL_LIGHT3,
							LIGHT4 = GL_LIGHT4, LIGHT5 = GL_LIGHT5, LIGHT6 = GL_LIGHT6, LIGHT7 = GL_LIGHT7;
	
	/**
	 * All of the available shape constants.
	 */
	public static final int QUADS = GL_QUADS, TRIANGLES = GL_TRIANGLES, POINTS = GL_POINTS;
	
	/**
	 * All of the render mode constants.
	 */
	public static final int ARRAYS = Base.ARRAYS, ELEMENTS = Base.ELEMENTS, IMMEDIATE = Base.IMMEDIATE;
	
	/**
	 * All of the directional constants.
	 */
	public static final int LEFT = 0, CENTER = 1, RIGHT = 2, TOP = 2, BOTTOM = 0, FRONT = GL_FRONT,
								BACK = GL_BACK, FRONT_AND_BACK = GL_FRONT_AND_BACK, CLOCKWISE = GL_CW,
								COUNTER_CLOCKWISE = GL_CCW;
	
	/**
	 * All of the shading model constants.
	 */
	public static final int SMOOTH = GL11.GL_SMOOTH, FLAT = GL11.GL_FLAT;
	
	/**
	 * All of the attribute bit constants.
	 */
	public static final int ALL_ATTRIB_BITS = GL_ALL_ATTRIB_BITS, ENABLE_BIT = GL_ENABLE_BIT, FOG_BIT = GL_FOG_BIT,
								LIGHTING_BIT = GL_LIGHTING_BIT, LINE_BIT = GL_LINE_BIT, POINT_BIT = GL_POINT_BIT,
								POLYGON_BIT = GL_POLYGON_BIT, TEXTURE_BIT = GL_TEXTURE_BIT,
								COLOR_BUFFER_BIT = GL_COLOR_BUFFER_BIT, CURRENT_BIT = GL_CURRENT_BIT;
	
	private static boolean DRAW_MODE_ARRAYS, DRAW_MODE_ELEMENTS, DRAW_MODE_IMMEDIATE, USING_VBO;
	
	static
	{
		showColors = true;
		
		Base.setUsingVBO(true); 
		Base.setDrawMode(ELEMENTS);
		
		update();
		
		Runtime.getRuntime().addShutdownHook(new Thread()
		{
			public void run()
			{
				
			}
		});
	}
	
	public static void update()
	{
		USING_VBO           = Base.isUsingVBO();
		
		DRAW_MODE_ARRAYS    = Base.getDrawMode() == Base.ARRAYS;
		DRAW_MODE_ELEMENTS  = Base.getDrawMode() == Base.ELEMENTS;
		DRAW_MODE_IMMEDIATE = Base.getDrawMode() == Base.IMMEDIATE;
	}
	
	public static String getVersion()
	{
		return version;
	}
	
	public static String getOpenGLVersion()
	{
		return GL11.glGetString(GL_VERSION);
	}
	
	public static boolean getBoolean(int pname)
	{
		return glGetBoolean(pname);
	}
	
	public static void getBoolean(int pname, ByteBuffer params)
	{
		glGetBoolean(pname, params);
	}
	
	public static int getInteger(int pname)
	{
		return glGetInteger(pname);
	}
	
	public static void getInteger(int pname, IntBuffer params)
	{
		glGetInteger(pname, params);
	}
	
	public static float getFloat(int pname)
	{
		return glGetFloat(pname);
	}
	
	public static void getFloat(int pname, FloatBuffer params)
	{
		glGetFloat(pname, params);
	}
	
	public static double getDouble(int pname)
	{
		return glGetDouble(pname);
	}
	
	public static void getDouble(int pname, DoubleBuffer params)
	{
		glGetDouble(pname, params);
	}
	
	public static String getString(int pname)
	{
		return glGetString(pname);
	}
	
	public static ByteBuffer glGetPointer(int pname)
	{
		return glGetPointer(pname);
	}
	
	public static ByteBuffer glGetPointer(int pname, long resultSize)
	{
		return glGetPointer(pname, resultSize);
	}
	
	/**
	 * Set the order in which you input the vertices to be define
	 * the front of a polygon. if CLOCKWISE, then if you input the
	 * vertices in a clockwise fashion, then it is the front. vice-
	 * versa with the COUNTER_CLOCKWISE constant.
	 * 
	 * @param face CLOCKWISE or COUNTER_CLOCKWISE.
	 */
	public static void setFrontFace(int face)
	{
		glFrontFace(face);
	}
	
	public static void setCullFace(int frontOrBack)
	{
		glCullFace(frontOrBack);
	}
	
	public static void enableCulling()
	{
		glEnable(GL_CULL_FACE);
	}
	
	public static void disableCulling()
	{
		glDisable(GL_CULL_FACE);
	}
	
	public static void pushAttribute(int attribute)
	{
		glPushAttrib(attribute);
	}
	
	public static void popAttribute()
	{
		glPopAttrib();
	}
	
	public static void setLineWidth(float lineWidth)
	{
		glLineWidth(lineWidth);
	}
	
	public static void setPointSize(float size)
	{
		glPointSize(size);
	}
	
	public static void setLinePattern(int factor, short pattern)
	{
		glLineStipple(factor, pattern);
	}
	
	public static boolean isLinePatternOn()
	{
		return glIsEnabled(GL_LINE_STIPPLE);
	}
	
	public static void enableLinePattern()
	{
		glEnable(GL_LINE_STIPPLE);
	}
	
	public static void disableLinePattern()
	{
		glDisable(GL_LINE_STIPPLE);
	}
	
	public static int getPolygonMode()
	{
		return glGetInteger(GL_POLYGON_MODE);
	}
	
	public static void setPolygonMode(int frontOrBack, int mode)
	{
		glPolygonMode(frontOrBack, mode);
	}
	
	public static void setPolygonPattern(ByteBuffer mask)
	{
		glPolygonStipple(mask);
	}
	
	public static boolean isPolygonPatternOn()
	{
		return glIsEnabled(GL_POLYGON_STIPPLE);
	}
	
	public static void enablePolygonPattern()
	{
		glEnable(GL_POLYGON_STIPPLE);
	}
	
	public static void disablePolygonPattern()
	{
		glDisable(GL_POLYGON_STIPPLE);
	}
	
	public static boolean isPolygonAntialiasingOn()
	{
		return glIsEnabled(GL_POLYGON_SMOOTH);
	}
	
	public static void enablePolygonAntialiasing()
	{
		glEnable(GL_POLYGON_SMOOTH);
	}
	
	public static void disablePolygonAntialiasing()
	{
		glDisable(GL_POLYGON_SMOOTH);
	}
	
	public static boolean isLineAntialiasingOn()
	{
		return glIsEnabled(GL_LINE_SMOOTH);
	}
	
	public static void enableLineAntialiasing()
	{
		glEnable(GL_LINE_SMOOTH);
	}
	
	public static void disableLineAntialiasing()
	{
		glDisable(GL_LINE_SMOOTH);
	}
	
	public static int getDrawMode()
	{
		return Base.getDrawMode();
	}
	
	public static void setDrawMode(int drawMode)
	{
		Base.setDrawMode(drawMode);
		
		update();
	}
	
	public static boolean isUsingVBO()
	{
		return Base.isUsingVBO();
	}
	
	public static void setUsingVBO(boolean usingVBO)
	{
		Base.setUsingVBO(usingVBO);
		
		update();
	}
	
	public static boolean isShowingColors()
	{
		return showColors;
	}
	
	public static void setShowColors(boolean showColors)
	{
		GL.showColors = showColors;
	}
	
	public static boolean isWireFrame()
	{
		return wireFrame;
	}
	
	public static void setWireFrameMode(boolean wireFrame)
	{
		setWireFrameMode(wireFrame, false, false);
	}
	
	public static void setWireFrameMode(boolean wireFrame, boolean textures, boolean colors)
	{
		GL.wireFrame      = wireFrame;
		
		GL.showColors = colors;
		
		if (textures)
		{
			glEnable(GL_TEXTURE_2D);
		}
		else
		{
			glDisable(GL_TEXTURE_2D);
		}
			
		if (wireFrame)
		{
			
			glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
		}
		else
		{
			glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
		}
	}
	
	/**
	 * Gets the white texture that can be used to create any solid
	 * color if glSetColor(r, g, b, a) is called before render.
	 * 
	 * @return The white Texture.
	 */
	public static Texture getWhite()
	{
		return white;
	}
	
	public static void glBegin(int mode)
	{
		GL11.glBegin(mode);
	}
	
	public static void glEnd()
	{
		GL11.glEnd();
	}
	
	public static void glLoadMatrix(FloatBuffer matrix)
	{
		GL11.glLoadMatrix(matrix);
	}
	
	public static void glColor3f(float r, float g, float b)
	{
		GL11.glColor3f(r, g, b);
	}
	
	public static void glVertex3f(float x, float y, float z)
	{
		GL11.glVertex3f(x, y, z);
	}
	
	public static void glVertex3d(double x, double y, double z)
	{
		GL11.glVertex3d(x, y, z);
	}
	
	public static void glVertex2f(float x, float y)
	{
		GL11.glVertex2f(x, y);
	}
	
	public static void glVertex2d(double x, double y)
	{
		GL11.glVertex2d(x, y);
	}
	
	public static void glTexCoord2f(float s, float t)
	{
		GL11.glTexCoord2f(s, t);
	}
	
//	/**
//	 * Create a rectangle at the specified position, with the specified
//	 * dimensions;
//	 * 
//	 * @param x The x position of the rectangle.
//	 * @param y The y position of the rectangle.
//	 * @param z The z position of the rectangle.
//	 * @param width The width of the rectangle.
//	 * @param height The height of the rectangle.
//	 * @return The id (position) of the rectangle.
//	 */
//	public static int createRect(float x, float y, float z, float width, float height)
//	{
//		if (rectVerticesBuffer == null)
//		{
//			throw new NullPointerException("You must use setAmountOfElements(int amount) before you can create any elements.");
//		}
//		
//		rectVerticesBuffer.get(rectVerticesPosition % (1000 * 4 * 3)).addData(addRectVertexArrayf(x, y, z, width, height, 0, null));
//		
//		rectVerticesPosition += 1;
//		
//		return rectVerticesPosition - 1;
//	}
	
//	/**
//	 * Set the texture offsets for the rectangle at the specified
//	 * position. To get the offsets array, use the method
//	 * ImageMap.getImageOffsetsf();
//	 * 
//	 * @param position The id (position) of the rectangle.
//	 * @param offsets The offsets of the texture.
//	 */
//	public static void setRectTextureOffsets(int position, float offsets[])
//	{
//		float textures[] = addRectTextureArrayf(offsets, 0, null);
//		
//		rectTexturesBuffer.get(rectTexturesPosition % (1000 * 4 * 3)).setData(position * 4 * 2, textures);
//	}
	
//	/**
//	 * Renders the rectangle at the specified position in the array.
//	 * 
//	 * @param position The id (position) of the rectangle.
//	 */
//	public static void renderRect(int position)
//	{
//		if (rectVerticesBuffer == null)
//		{
//			return;
//		}
//		
//		beginVertexDraw(rectVerticesBuffer.get(rectVerticesPosition % (1000 * 4 * 3)), 3);
//		beginTextureDraw(rectTexturesBuffer.get(rectVerticesPosition % (1000 * 4 * 3)), 2);
//		
//		glDrawArrays(QUADS, position * 4, 4);
//		
//		endTextureDraw();
//		endVertexDraw();
//	}
	
//	/**
//	 * Renders all of the rectangles to the screen.
//	 */
//	public static void renderRects()
//	{
//		if (rectVerticesBuffer == null)
//		{
//			return;
//		}
//		
//		beginVertexDraw(rectVerticesBuffer.get(rectVerticesPosition % (1000 * 4 * 3)), 3);
//		beginTextureDraw(rectTexturesBuffer.get(rectVerticesPosition % (1000 * 4 * 3)), 2);
//		
//		glDrawArrays(QUADS, 0, rectVerticesPosition * 4);
//		
//		endTextureDraw();
//		endVertexDraw();
//	}
	
	/**
	 * Set the color to the specified float values. Default color is
	 * (1, 1, 1, 1)
	 * 
	 * @param r The red value. (0.0f - 1.0f)
	 * @param g The green value. (0.0f - 1.0f)
	 * @param b The blue value. (0.0f - 1.0f)
	 * @param a The alpha value. (0.0f - 1.0f)
	 */
	public static void setColorf(float r, float g, float b, float a)
	{
		glColor4f(r, g, b, a);
	}
	
	/**
	 * Sets the color to the specified integer vales. Default color is
	 * (255, 255, 255, 255)
	 * This is the more known way of setting rgb colors.
	 * 
	 * @param r The red value (0 - 255)
	 * @param g The green value (0 - 255)
	 * @param b The blue value (0 - 255)
	 * @param a The alpha value (0 - 255)
	 */
	public static void setColori(int r, int g, int b, int a)
	{
		glColor4f(r / 255f, g / 255f, b / 255f, a / 255f);
	}
	
	/**
	 * Set the color in which the screen will clear to, to the specified
	 * float values. Default color is (1, 1, 1, 1).
	 * 
	 * @param r The red value. (0.0f - 1.0f)
	 * @param g The green value. (0.0f - 1.0f)
	 * @param b The blue value. (0.0f - 1.0f)
	 * @param a The alpha value. (0.0f - 1.0f)
	 */
	public static void setClearColorf(float r, float g, float b, float a)
	{
		glClearColor(r, g, b, a);
	}
	
	/**
	 * Set the color in which the screen will clear to, to the specified
	 * integer values. Default color is (255, 255, 255, 255).
	 * 
	 * @param r The red value (0 - 255)
	 * @param g The green value (0 - 255)
	 * @param b The blue value (0 - 255)
	 * @param a The alpha value (0 - 255)
	 */
	public static void setClearColori(int r, int g, int b, int a)
	{
		glClearColor(r / 255f, g / 255f, b / 255f, a / 255f);
	}
	
	/**
	 * Renders all of the rectangles within the specified dimensions.
	 * 
	 * @param x The x offset to render.
	 * @param y The y offset to render.
	 * @param width The width of the amount of rectangles to render.
	 * @param height The height of the amount of rectangles to render.
	 * @param verticesBuffer The LightBuffer that holds the information
	 * 		for the vertices.
	 * @param texturesBuffer The LightBuffer that holds the information
	 * 		for the texture offsets.
	 * @param imageMap The ImageMap that will be bound and used for
	 * 		drawing the textures.
	 * @param arrayWidth The width of the buffer array to loop through.
	 * @param arrayHeight The height of the buffer array to loop through.
	 */
	public static void renderQuadRect(int x, int y, int width, int height, VerticesBuffer verticesBuffer, LightBuffer texturesBuffer, ImageMap imageMap, int arrayWidth, int arrayHeight, int vertexSize)
	{
		beginVertexDraw(verticesBuffer);
		beginTextureDraw(texturesBuffer);
		
		imageMap.bind();
		
		renderRect(x, y, width, height, 4, arrayWidth, arrayHeight, QUADS);
		
		endTextureDraw();
		endVertexDraw();
	}
	
	/**
	 * Renders all of the rectangles within the specified dimensions.
	 * 
	 * @param x The x offset to render.
	 * @param y The y offset to render.
	 * @param width The width of the amount of rectangles to render.
	 * @param height The height of the amount of rectangles to render.
	 * @param arrayWidth The width of the buffer array to loop through.
	 * @param arrayHeight The height of the buffer array to loop through.
	 */
	public static void renderQuadRect(int x, int y, int width, int height, int arrayWidth, int arrayHeight)
	{
		renderRect(x, y, width, height, 4, arrayWidth, arrayHeight, QUADS);
	}
	
//	public static void drawQuad(int x, int y, int z, int width, int height)
//	{
//		glDrawArrays(GL_QUADS, 0, 1);
//	}
	
	/**
	 * Renders an array of rectangles within the specified dimensions.
	 * 
	 * @param x The x offset to render.
	 * @param y The y offset to render.
	 * @param width The width of the amount of rectangles to render.
	 * @param height The height of the amount of rectangles to render.
	 * @param stride The stride from one vertex to another.
	 * @param arrayWidth The width of the buffer array to loop through.
	 * @param arrayHeight The height of the buffer array to loop through.
	 * @param type The type of object that is being rendered.
	 */
	private static void renderRect(int x, int y, int width, int height, int stride, int arrayWidth, int arrayHeight, int type)
	{
		int mode = type;
		
		if (type == QUADS)
		{
			mode = TRIANGLES;
		}
		
		if (x + width >= arrayWidth)
		{
			width = arrayWidth - x;
		}
		if (y + height >= arrayHeight)
		{
			height = arrayHeight - y;
		}
		
		for (int i = y; i < height + y; i ++)
		{
			int dx = x * stride + (i * stride * arrayWidth);
			
			glDrawArrays(mode, dx, width * stride);
		}
	}
	
	/**
	 * Begins the manipulation of the current matrix.
	 */
	public static void beginManipulation()
	{
		tempOffsets.add(offsets.clone());
		tempScale.add(scale.clone());
		tempRenderLocation.add(renderLocation.clone());
		
		glPushMatrix();
	}
	
	/**
	 * Ends the manipulation of the current matrix and returns to
	 * the matrix before beginManipulation() was called.
	 */
	public static void endManipulation()
	{
		double temp[] = tempOffsets.get(tempOffsets.size() - 1);
		
		offsets[0] = temp[0];
		offsets[1] = temp[1];
		offsets[2] = temp[2];
		
		tempOffsets.remove(tempOffsets.size() - 1);
		
		
		temp = tempScale.get(tempScale.size() - 1);
		
		scale[0] = temp[0];
		scale[1] = temp[1];
		scale[2] = temp[2];
		
		tempScale.remove(tempScale.size() - 1);
		
		
		temp = tempRenderLocation.get(tempRenderLocation.size() - 1);
		
		renderLocation[0] = temp[0];
		renderLocation[1] = temp[1];
		renderLocation[2] = temp[2];
		
		tempRenderLocation.remove(tempRenderLocation.size() - 1);
		
		glPopMatrix();
	}
	
	/**
	 * Enables the ability to clip a part of the screen for rendering.
	 */
	public static void enableClipping()
	{
		glEnable(GL_SCISSOR_TEST);
	}
	
	/**
	 * Ends the ability to clip a part of the screen for rendering.
	 */
	public static void endClipping()
	{
		glDisable(GL_SCISSOR_TEST);
	}
	
	/**
	 * Enables the ability to invert anything rendered.
	 */
	public static void enableInverting()
	{
		glEnable(GL_COLOR_LOGIC_OP);
	}
	
	/**
	 * Ends the ability to invert anything rendered.
	 */
	public static void endInverting()
	{
		glDisable(GL_COLOR_LOGIC_OP);
	}
	
	/**
	 * Begin inverting everything rendered according to the opposite
	 * of their rgb values.
	 */
	public static void beginInverting()
	{
		enableInverting();
		
		/*
		 * GL_CLEAR
		 * GL_SET
		 * GL_COPY
		 * GL_COPY_INVERTED
		 * GL_NOOP
		 * GL_INVERT
		 * GL_AND
		 * GL_NAND
		 * GL_OR
		 * GL_NOR
		 * GL_XOR
		 * GL_EQUIV
		 * GL_AND_REVERSE
		 * GL_AND_INVERTED
		 * GL_OR_REVERSE
		 * GL_OR_INVERTED 
		 */
		
		glLogicOp(GL_COPY_INVERTED);
	}
	
	/**
	 * Begins inverting everything rendered according to whatever is
	 * being rendered behind it.
	 */
	public static void beginInvertingBackground()
	{
		enableInverting();
		
		/*
		 * GL_CLEAR
		 * GL_SET
		 * GL_COPY
		 * GL_COPY_INVERTED
		 * GL_NOOP
		 * GL_INVERT
		 * GL_AND
		 * GL_NAND
		 * GL_OR
		 * GL_NOR
		 * GL_XOR
		 * GL_EQUIV
		 * GL_AND_REVERSE
		 * GL_AND_INVERTED
		 * GL_OR_REVERSE
		 * GL_OR_INVERTED 
		 */
		
		glLogicOp(GL_INVERT);
	}
	
	/**
	 * Begins inverting everything by XORing them.
	 */
	public static void beginXOR()
	{
		enableInverting();
		
		/*
		 * GL_CLEAR
		 * GL_SET
		 * GL_COPY
		 * GL_COPY_INVERTED
		 * GL_NOOP
		 * GL_INVERT
		 * GL_AND
		 * GL_NAND
		 * GL_OR
		 * GL_NOR
		 * GL_XOR
		 * GL_EQUIV
		 * GL_AND_REVERSE
		 * GL_AND_INVERTED
		 * GL_OR_REVERSE
		 * GL_OR_INVERTED 
		 */
		
		glLogicOp(GL_NOR);
	}
	
	/**
	 * Begins clipping the render frame at the specified position with
	 * the specified dimensions.
	 * 
	 * @param x The x position on the Frame to start clipping.
	 * @param y The y position of the Frame to start clipping.
	 * @param width The width of the area to be not clipped out.
	 * @param height The height of the area to be not clipped out.
	 */
	public static void beginClipping(int x, int y, int width, int height)
	{
		enableClipping();
		
		glScissor(x, y, width, height);
	}
	
	public static void setShadeModel(int model)
	{
		glShadeModel(model);
	}
	
	public static void setAmbientLighti(int r, int g, int b)
	{
		setAmbientLightf(r / 255f, g / 255f, b / 255f);
	}
	
	public static void setAmbientLightf(float r, float g, float b)
	{
//		glEnable(GL_LIGHT0);
		
		FloatBuffer ambLight = BufferUtils.createFloatBuffer(4).put(new float[]{ r, g, b, 1f });
		ambLight.rewind();
		
		glLightModel(GL_LIGHT_MODEL_AMBIENT, ambLight);
//		glLight(GL_LIGHT0, GL_AMBIENT, ambLight);
		
		ambientLight    = new float[4];
		ambientLight[0] = r;
		ambientLight[1] = g;
		ambientLight[2] = b;
		ambientLight[3] = 1;
		
		setLightProperties();
	}
	
	public static void addLight(Vector direction, float degrees)
	{
		glEnable(GL_LIGHT0);
		
		FloatBuffer dif = BufferUtils.createFloatBuffer(4);
		dif.put(new float[] { 1.5f, 1.5f, 1.5f, 1 });
		dif.rewind();
		
		FloatBuffer amb = BufferUtils.createFloatBuffer(4);
		amb.put(new float[] { 0.15f, 0.15f, 0.15f, 1 });
		amb.rewind();
		
		FloatBuffer pos = BufferUtils.createFloatBuffer(4);
		pos.put(new float[] { 0f, 0f, 0f, 1 });
		pos.rewind();
		
		glLight(GL_LIGHT0, GL_AMBIENT, amb);
		glLight(GL_LIGHT0, GL_DIFFUSE, dif);
//		glLight(GL_LIGHT0, GL_SPECULAR, white);
		
		glLight(GL_LIGHT0, GL_POSITION, pos);
		
		glLightf(GL_LIGHT0, GL_SPOT_CUTOFF, degrees / 2);
		
		FloatBuffer direc = BufferUtils.createFloatBuffer(4);
		direc.put(new float[] { direction.getX(), direction.getY(), direction.getZ(), 1 });
		direc.rewind();
		
		glLight(GL_LIGHT0, GL_SPOT_DIRECTION, direc);
		
		glLightf(GL_LIGHT0, GL_SPOT_EXPONENT, 128);
	}
	
	public static void setLighting()
	{
		glEnable(GL_LIGHT0);
		
		FloatBuffer dif = BufferUtils.createFloatBuffer(4);
		dif.put(new float[] { 0.f, 0.f, 0.f, 1 }); //set the LightPosition to the specified values
		dif.rewind();
		    
	    FloatBuffer amb = BufferUtils.createFloatBuffer(4);
	    amb.put(new float[] { 0.f, 0.f, 0.f, 1 }); //set the LightPosition to the specified values
	    amb.rewind();
	    
	    glLight(GL_LIGHT0, GL_DIFFUSE, dif); //change the light accordingly
	    glLight(GL_LIGHT0, GL_AMBIENT, amb); //change the light accordingly
	    
	    FloatBuffer pos = BufferUtils.createFloatBuffer(4);
	    pos.put(new float[] { 0, 0, 0, 1 }); //set the LightPosition to the specified values
	    pos.rewind();
	    
	    glLight(GL_LIGHT0, GL_POSITION, pos); //change the light accordingly
	}
	
	public static void addDiffuse(int lightNumber, Point color)
	{
		glEnable(lightNumber);
		
		FloatBuffer dif = BufferUtils.createFloatBuffer(4);
		dif.put(new float[] { color.getX(), color.getY(), color.getZ(), 1 });
		dif.rewind();
		
		glLight(lightNumber, GL_DIFFUSE, dif);
	}
	
	public static void addSpecular(int lightNumber, Point color)
	{
		glEnable(lightNumber);
		
		FloatBuffer spec = BufferUtils.createFloatBuffer(4);
		spec.put(new float[] { color.getX(), color.getY(), color.getZ(), 1 });
		spec.rewind();
		
//		glLight(lightNumber, GL_SPECULAR, spec);
	}
	
	public static void setReflection(Point reflectColor)
	{
		FloatBuffer specReflec = BufferUtils.createFloatBuffer(4);
		specReflec.put(new float[] { reflectColor.getX(), reflectColor.getY(), reflectColor.getZ(), 1 });
		specReflec.rewind();
		
		glMaterial(GL_FRONT, GL_SPECULAR, specReflec);
	}
	
	public static void setShininess(int shininess)
	{
		glMateriali(GL_FRONT, GL_SHININESS, shininess);
	}
	
	public static void setLightLocation(int lightNumber, Point location)
	{
		FloatBuffer pos = BufferUtils.createFloatBuffer(4);
		pos.put(new float[] { location.getX(), location.getY(), location.getZ(), 1 });
		pos.rewind();
		
		glLight(lightNumber, GL_POSITION, pos);
	}
	
	/**
	 * Initialize the OpenGL lighting.
	 */
	public static void initLighting()
	{
//		glEnable(GL_COLOR_MATERIAL);
//		glColorMaterial(GL_FRONT, GL_DIFFUSE);
        
		glEnable(GL_DEPTH_TEST);
		glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
		glEnable(GL_COLOR_MATERIAL);
		glEnable(GL_LIGHTING);
//		glEnable(GL_LIGHT0);
//		glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 0);
//		glLightModeli(GL_FRONT, GL_DIFFUSE);
//		glEnable(GL_NORMALIZE);
	}
	
//	public static void startNormal()
//	{
//		glNormal3f(0, 0, 1);
//	}
	
	/**
	 * Set the GL_LIGHT0 location to the specified location.
	 * 
	 * @param x The x position in the scene.
	 * @param y The y position in the scene.
	 * @param z The z position in the scene.
	 */
	private static void setLightLocation(int lightId, float x, float y, float z)
	{
		FloatBuffer pos = BufferUtils.createFloatBuffer(4);
		pos.put(new float[] { x, y, z, 1.0f }).rewind();
		
//		FloatBuffer dif = BufferUtils.createFloatBuffer(4);
//		dif.put(new float[] { 0.6f, 0.2f, 0.2f, 1.0f }).rewind();
		
//		glLight(lightId, GL_POSITION, pos);
//		glLight(GL_LIGHT0, GL_DIFFUSE, dif);
	}
	
//	/**
//	 * Create a new light to be rendered in the scene.
//	 */
//	public static void light()
//	{
//		FloatBuffer amb = BufferUtils.createFloatBuffer(4);
//		amb.put(new float[] { -0.2f, -0.2f, -0.2f, 1.0f }).flip();
//		
//		FloatBuffer dif = BufferUtils.createFloatBuffer(4);
//		dif.put(new float[] { 10f, 10f, 10f, 1.0f }).flip();
//		
////		FloatBuffer spe = BufferUtils.createFloatBuffer(8);
////		spe.put(new float[] { 0.0f, 0.0f, 0.0f, 1.0f }).flip();
//		
//		glLight(GL_LIGHT0, GL_AMBIENT, amb);
//		glLight(GL_LIGHT0, GL_DIFFUSE, dif);
////		glLight(GL_LIGHT0, GL_SPECULAR, spe);
//	}
	
	public static void setLightProperties()
	{
//		FloatBuffer black = BufferUtils.createFloatBuffer(4);
//		black.put(new float[] { 0, 0, 0, 1 }).rewind();
//		
//		FloatBuffer green = BufferUtils.createFloatBuffer(4);
//		green.put(new float[] { 0, 1, 0, 1 }).rewind();
		
		FloatBuffer amb = BufferUtils.createFloatBuffer(4);
		amb.put(new float[] { ambientLight[0], ambientLight[1], ambientLight[2], ambientLight[3] }).rewind();
		
		glMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, amb);
//		glMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE, amb);
//		glMaterial(GL_FRONT, GL_SPECULAR, amb);
		
//		glMaterialf(GL_FRONT, GL_SHININESS, 60.0f);
	}
	
	public static int genFrameBuffer()
	{
		return GL30.glGenFramebuffers();
	}
	
	public static int beginScreenCapture()
	{
		return beginScreenCapture(genFrameBuffer());
	}
	
	public static int beginScreenCapture(int frameBufferId)
	{
		glEnable(GL_TEXTURE_2D);
		
		// Bind Framebuffer
		GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, frameBufferId);
		
		// The texture we're going to render to
		int renderedTexture = glGenTextures();
		glBindTexture(GL_TEXTURE_2D, renderedTexture);
		ByteBuffer buffer = BufferUtils.createByteBuffer(Frame.getWidth() * Frame.getHeight() * 4);
		GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA8, Frame.getWidth(), Frame.getHeight(), 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, buffer);
		
		// The depth buffer
		int depthRenderBuffer = GL30.glGenRenderbuffers();
		GL30.glBindRenderbuffer(GL30.GL_RENDERBUFFER, depthRenderBuffer);
		GL30.glRenderbufferStorage(GL30.GL_RENDERBUFFER, GL_DEPTH_COMPONENT, Frame.getWidth(), Frame.getHeight());
		GL30.glBindRenderbuffer(GL30.GL_RENDERBUFFER, 0);
		
		// Attach Texture to Framebuffer
		GL30.glFramebufferTexture2D(GL30.GL_FRAMEBUFFER, GL30.GL_COLOR_ATTACHMENT0, GL11.GL_TEXTURE_2D, renderedTexture, 0);
		
		// Attach Renderbuffer to Framebuffer
		GL30.glFramebufferRenderbuffer(GL30.GL_FRAMEBUFFER, GL30.GL_DEPTH_ATTACHMENT, GL30.GL_RENDERBUFFER, depthRenderBuffer);
		
		// Always check that our framebuffer is ok
		if(GL30.glCheckFramebufferStatus(GL30.GL_FRAMEBUFFER) != GL30.GL_FRAMEBUFFER_COMPLETE)
		{
			throw new RuntimeException("FrameBuffer unable to complete!");
		}
		
		GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, 0);
		GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, frameBufferId);
//		glPushAttrib(GL_VIEWPORT_BIT);
//		glViewport(0, 0, Frame.getWidth(), Frame.getHeight());
		
		
//		// "Bind" the newly created texture : all future texture functions will modify this texture
//		glBindTexture(GL_TEXTURE_2D, renderedTexture);
//		 
//		// Give an empty image to OpenGL ( the last "0" )
//		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, Frame.getWidth(), Frame.getHeight(), 0, GL_RGB, GL_UNSIGNED_BYTE, 0);
//		 
//		// Poor filtering. Needed !
//		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
//		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		
		
		
//		// Set "renderedTexture" as our colour attachement #0
////		GL30.glFramebufferTexture(GL30.GL_FRAMEBUFFER, GL30.GL_COLOR_ATTACHMENT0, renderedTexture, 0);
//		GL30.glFramebufferTexture2D(GL30.GL_FRAMEBUFFER, GL30.GL_COLOR_ATTACHMENT0, renderedTexture, renderedTexture, 0);
//		 
//		// Set the list of draw buffers.
////		GLenum DrawBuffers[2] = {GL_COLOR_ATTACHMENT0};
////		glDrawBuffers(1, DrawBuffers); // "1" is the size of DrawBuffers
//		glDrawBuffer(GL30.GL_COLOR_ATTACHMENT0);
//		
//		// Always check that our framebuffer is ok
//		if(GL30.glCheckFramebufferStatus(GL30.GL_FRAMEBUFFER) != GL30.GL_FRAMEBUFFER_COMPLETE)
//		{
//			throw new RuntimeException("FrameBuffer unable to complete!");
//		}
//		
//		// Render to our framebuffer
//		GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, frameBufferId);
//		glViewport(0, 0, Frame.getWidth(), Frame.getHeight()); // Render on the whole framebuffer, complete from the lower left corner to the upper right
		
//		GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, 0);
//		GL30.glBindRenderbuffer(GL30.GL_RENDERBUFFER, 0);
//		glBindBuffer(GL21.GL_PIXEL_UNPACK_BUFFER, 0);
		
		return renderedTexture;
	}
	
	public static void endScreenCapture()
	{
//		glPopAttrib();
		
		GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, 0);
//		GL30.glBindRenderbuffer(GL30.GL_RENDERBUFFER, 0);
//		glBindBuffer(GL21.GL_PIXEL_UNPACK_BUFFER, 0);
	}

	/**
	 * Rotates the scene the specified float amount for each axes.
	 * 
	 * @param x The amount to rotate along the x axis.
	 * @param y The amount to rotate along the y axis.
	 * @param z The amount to rotate along the z axis.
	 */
	public static void rotatef(float x, float y, float z)
	{
		rotated(x, y, z);
	}
	
	/**
	 * Rotates the scene the specified double amount for each axes.
	 * 
	 * @param x The amount to rotate along the x axis.
	 * @param y The amount to rotate along the y axis.
	 * @param z The amount to rotate along the z axis.
	 */
	public static void rotated(double x, double y, double z)
	{
		if (x != 0)
		{
			glRotated(x, 1, 0, 0);
		}
		if (y != 0)
		{
			glRotated(y, 0, 1, 0);
		}
		if (z != 0)
		{
			glRotated(z, 0, 0, 1);
		}
	}
	
	/**
	 * Scales everything rendered on the scene the specified float
	 * amount.
	 * 
	 * @param x The amount to scale the width.
	 * @param y The amount to scale the height.
	 * @param z The amount to scale the depth.
	 */
	public static void scalef(float x, float y, float z)
	{
		scaled(x, y, z);
	}
	
	/**
	 * Scales everything rendered on the scene the specified double
	 * amount.
	 * 
	 * @param x The amount to scale the width.
	 * @param y The amount to scale the height.
	 * @param z The amount to scale the depth.
	 */
	public static void scaled(double x, double y, double z)
	{
		glScaled(x, y, z);
		
		scale[0] *= x;
		scale[1] *= y;
		scale[2] *= z;
	}
	
	/**
	 * Translates the scene rendered on the scene to the specified float
	 * position.
	 * 
	 * @param x The amount to translate the x.
	 * @param y The amount to translate the y.
	 * @param z The amount to translate the z.
	 */
	public static void translatef(float x, float y, float z)
	{
		translated(x, y, z);
	}
	
	/**
	 * Translates the scene rendered on the scene to the specified Point.
	 * 
	 * @param p The Point to translate to.
	 */
	public static void translatef(Point p)
	{
		translatef(p.getX(), p.getY(), p.getZ());
	}
	
	/**
	 * Scales the scene rendered on the scene to the specified double
	 * position.
	 * 
	 * @param x The amount to translate the x.
	 * @param y The amount to translate the y.
	 * @param z The amount to translate the z.
	 */
	public static void translated(double x, double y, double z)
	{
		glTranslated(x, y, z);
		
		offsets[0] += x;
		offsets[1] += y;
		offsets[2] += z;
		
		renderLocation[0] += x * scale[0];
		renderLocation[1] += y * scale[1];
		renderLocation[2] += z * scale[2];
		
//		updateLighting();
	}
	
	/**
	 * Returns the amount translated by the time that this method
	 * is called.
	 * 
	 * @return The amount translated so far.
	 */
	public static double[] getAmountTranslated()
	{
		return offsets.clone();
	}
	
	/**
	 * Returns the amount scaled by the time that this method
	 * is called.
	 * 
	 * @return The amount scaled so far.
	 */
	public static double[] getAmountScaled()
	{
		return scale.clone();
	}
	
	/**
	 * Returns the location at which anything rendered to the screen
	 * at 0, 0, 0 would currently be shown on the screen.
	 * 
	 * @return The location at which any component would be rendered.
	 */
	public static double[] getRenderLocation()
	{
		return renderLocation.clone();
	}
	
	/**
	 * Method that gets the amount of vertices that the specified type
	 * of object needs to be created with.
	 * 
	 * EX: Quads need 4 vertices and triangles need 3.
	 * 
	 * @param type
	 * @return
	 */
	public static int getAmountOfVertices(int type)
	{
		if (type == QUADS)
		{
			return 4;
		}
		else if (type == TRIANGLES)
		{
			return 3;
		}
		
		return 0;
	}
	
	public static void renderCubes(VerticesBuffer verticesBuffer, LightBuffer colorsBuffer, int start, int amount)
	{
		renderBuffers(verticesBuffer, null, null, colorsBuffer, null, start * 6, amount * 6, QUADS, null);
	}
	
	public static void renderCubes(VerticesBuffer verticesBuffer, LightBuffer texturesBuffer, LightBuffer colorsBuffer, Texture texture, int start, int amount)
	{
		renderBuffers(verticesBuffer, texturesBuffer, null, colorsBuffer, texture, start * 6, amount * 6, QUADS, null);
	}
	
	public static void renderCubes(VerticesBuffer verticesBuffer, int start, int amount)
	{
		renderBuffers(verticesBuffer, null, null, null, null, start * 6, amount * 6, QUADS, null);
	}

	public static void renderCubes(VerticesBuffer verticesBuffer, LightBuffer textures, Texture texture, int start, int amount)
	{
		renderBuffers(verticesBuffer, textures, null, null, texture, start * 6, amount * 6, QUADS, null);
	}
	
	public static void renderCubes(VerticesBuffer verticesBuffer, LightBuffer texturesBuffer, LightBuffer normalsBuffer, LightBuffer colorsBuffer, Texture texture, int start, int amount, Task task)
	{
		renderBuffers(verticesBuffer, texturesBuffer, normalsBuffer, colorsBuffer, texture, start * 6, amount * 6, QUADS, task);
	}
	
	public static void renderQuads(VerticesBuffer verticesBuffer, int start, int amount)
	{
		renderBuffers(verticesBuffer, null, null, null, null, start, amount, QUADS, null);
	}
	
	public static void renderQuads(VerticesBuffer verticesBuffer, LightBuffer texturesBuffer, LightBuffer normalsBuffer, Texture imageMap, int start, int amount)
	{
		renderBuffers(verticesBuffer, texturesBuffer, normalsBuffer, null, imageMap, start, amount, QUADS, null);
	}
	
	public static void renderQuads(VerticesBuffer verticesBuffer, LightBuffer texturesBuffer, Texture imageMap, int start, int amount, Task task)
	{
		renderBuffers(verticesBuffer, texturesBuffer, null, null, imageMap, start, amount, QUADS, task);
	}
	
	public static void renderQuads(VerticesBuffer verticesBuffer, LightBuffer texturesBuffer, Texture imageMap, int start, int amount)
	{
		renderBuffers(verticesBuffer, texturesBuffer, null, null, imageMap, start, amount, QUADS, null);
	}
	
	public static void renderQuad(VerticesBuffer verticesBuffer, LightBuffer texturesBuffer, Texture imageMap)
	{
		renderBuffers(verticesBuffer, texturesBuffer, null, null, imageMap, 0, 1, QUADS, null);
	}
	
	public static void renderQuads(int verticesBufferId, int vertexSize, int texturesBufferId, int normalsBufferId, int colorsBufferId, int vertexIndicesId, Texture texture, int start, int amount, Task task)
	{
		renderBuffers(verticesBufferId, vertexSize, texturesBufferId, normalsBufferId, colorsBufferId, vertexIndicesId, texture, start, amount, QUADS, task);
	}
	
	public static void renderQuads(VerticesBuffer verticesBuffer, LightBuffer texturesBuffer, LightBuffer normalsBuffer, LightBuffer colorsBuffer, Texture texture, int start, int amount, Task task)
	{
		renderBuffers(verticesBuffer, texturesBuffer, normalsBuffer, colorsBuffer, texture, start, amount, QUADS, task);
	}
	
	public static void renderTriangles(VerticesBuffer verticesBuffer, int start, int amount)
	{
		renderBuffers(verticesBuffer, null, null, null, null, start, amount, TRIANGLES, null);
	}
	
	public static void renderTriangles(VerticesBuffer verticesBuffer, LightBuffer texturesBuffer, LightBuffer normalsBuffer, LightBuffer colorsBuffer, Texture texture, int start, int amount, Task task)
	{
		renderBuffers(verticesBuffer, texturesBuffer, normalsBuffer, colorsBuffer, texture, start, amount, TRIANGLES, task);
	}
	
	/**
	 * Renders all of the given buffers. The only needed arguments are the
	 * verticesBuffer, start, amount, and type. The rest of the arguments
	 * can be null and the method will still work.
	 * 
	 * @param verticesBuffer The Buffer that holds all of the data for
	 * 		vertices.
	 * @param texturesBuffer The Buffer that holds all of the data for
	 * 		textures.
	 * @param normalsBuffer The Buffer that holds all of the data for
	 * 		normals per vertex.
	 * @param colorsBuffer The Buffer that holds all of the data for
	 * 		colors.
	 * @param texture The Texture or SpriteSheet needed for the
	 * 		textures Buffer.
	 * @param start The index of the first shape in the verticesBuffer.
	 * @param amount The amount of shapes you want to draw from the
	 * 		verticesBuffer.
	 * @param type The type of shape that will be drawn.
	 * @param task The task that will run in between each of the shapes.
	 * 		This slows down the process a lot if there are many being drawn.
	 */
	private static void renderBuffers(VerticesBuffer verticesBuffer, LightBuffer texturesBuffer, LightBuffer normalsBuffer, LightBuffer colorsBuffer, Texture texture, int start, int amount, int type, Task task)
	{
		if (verticesBuffer == null)
		{
			throw new IllegalArgumentException("verticesBuffer cannot be null.");
		}
		
		int vId  = 0;
		int vs   = 0;
		int viId = 0;
		int tId  = 0;
		int nId  = 0;
		int cId  = 0;
		
		if (verticesBuffer != null)
		{
			vId  = verticesBuffer.getId();
			vs   = verticesBuffer.getVertexSize();
			viId = verticesBuffer.getIndicesId(0);
		}
		if (texturesBuffer != null)
		{
			tId = texturesBuffer.getId();
		}
		if (normalsBuffer != null)
		{
			nId = normalsBuffer.getId();
		}
		if (colorsBuffer != null)
		{
			cId = colorsBuffer.getId();
		}
		
		renderBuffers(vId, vs, tId, nId, cId, viId, texture, start, amount, type, task);
	}
	
	private static void renderBuffers(int verticesBufferId, int vertexSize, int texturesBufferId, int normalsBufferId, int colorsBufferId, int vertexIndicesId, Texture texture, int start, int amount, int type, Task task)
	{
		int amountOfVertices = getAmountOfVertices(type);
		
		start   *= amountOfVertices;
		amount  *= amountOfVertices;
		
		int mode = type;
		
		if (type == QUADS)
		{
			mode    = TRIANGLES;
			
			start  *= 1.5f;
			amount *= 1.5f;
		}
		
		if (DRAW_MODE_ARRAYS || DRAW_MODE_ELEMENTS)
		{
			beginTextureDraw(texturesBufferId);
			beginVertexDraw(verticesBufferId, vertexSize);
			beginNormalDraw(normalsBufferId);
			beginColorDraw(colorsBufferId);
		}
		
		if (texture != null)
		{
			texture.bind();
		}
		
		if (task != null)
		{
			float vertices[] = null;
			float textures[] = null;
			float colors[]   = null;
			
//			if (DRAW_MODE_IMMEDIATE)
//			{
//				vertices = verticesBuffer.getData();
//				
//				if (texture != null)
//				{
//					textures = texturesBuffer.getData();
//				}
//				if (colorsBuffer != null)
//				{
//					colors = colorsBuffer.getData();
//				}
//			}
			
			for (int i = start; i < start + amount; i += amountOfVertices)
			{
				if (!task.run(i / amountOfVertices))
				{
					continue;
				}
				
				if (DRAW_MODE_ARRAYS)
				{
					glDrawArrays(mode, start + i, amountOfVertices);
				}
//				else if (DRAW_MODE_ELEMENTS)
//				{
//					if (isUsingVBO())
//					{
////						GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, verticesBuffer.getIndicesId());
//						
////						GL11.glDrawElements(type, amountOfVertices, GL_UNSIGNED_SHORT, (start + i) * 2);
//					}
//					else
//					{
//						GL12.glDrawRangeElements(mode, 0, amount, verticesBuffer.getIndices(start));
//					}
////					GL12.glDrawRangeElements(type, 0, amountOfVertices + start + i, verticesBuffer.getIndices(start + i));
//				}
				else if (DRAW_MODE_IMMEDIATE)
				{
//					for (int f = start; f < start + amount; f += amountOfVertices)
//					{
						GL11.glBegin(mode);
						{
							int textureOffset = i * 2;
							int vertexOffset  = i * vertexSize;
							int colorOffset   = i * 4;
							
							for (int j = 0; j < amountOfVertices; j ++)
							{
								if (colors != null && showColors)
								{
									glColor4f(colors[0 + colorOffset], colors[1 + colorOffset], colors[2 + colorOffset], colors[3 + colorOffset]);
								}
								if (texture != null)
								{
									glTexCoord2f(textures[textureOffset], textures[1 + textureOffset]);
								}
								if (vertexSize == 3)
								{
									glVertex3f(vertices[0 + vertexOffset], vertices[1 + vertexOffset], vertices[2 + vertexOffset]);
								}
								else if (vertexSize == 2)
								{
									glVertex2f(vertices[0 + vertexOffset], vertices[1 + vertexOffset]);
								}
								
								textureOffset += 2;
								vertexOffset  += vertexSize;
								colorOffset   += 4;
							}
						}
						GL11.glEnd();
//					}
				}
			}
		}
		else
		{
			if (DRAW_MODE_ARRAYS)
			{
				if (isUsingVBO())
				{
//					GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, verticesBuffer.getIndicesId());
					GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, vertexIndicesId);
					
					glDrawArrays(mode, start, amount);
					
					GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);
				}
				else
				{
					glDrawArrays(mode, start, amount);
				}
			}
			else if (DRAW_MODE_ELEMENTS)
			{
				if (isUsingVBO())
				{
//					GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, verticesBuffer.getIndicesId());
					GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, vertexIndicesId);
					
					GL11.glDrawElements(mode, amount, GL_UNSIGNED_SHORT, start * 2);
					
					GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, 0);
				}
//				else
//				{
//					GL12.glDrawRangeElements(mode, 0, amount + start, verticesBuffer.getIndices(start));
////					GL11.glDrawElements(mode, verticesBuffer.getIndices(start));
//				}
			}
//			else if (DRAW_MODE_IMMEDIATE)
//			{
//				float vertices[] = verticesBuffer.getData();
//				float textures[] = null;
//				float colors[]   = null;
//				
//				if (texture != null)
//				{
//					textures = texturesBuffer.getData();
//				}
//				if (colorsBuffer != null)
//				{
//					colors = colorsBuffer.getData();
//				}
//				
//				for (int i = start; i < start + amount; i += amountOfVertices)
//				{
//					GL11.glBegin(mode);
//					{
//						int textureOffset = i * 2;
//						int vertexOffset  = i * vertexSize;
//						int colorOffset   = i * 4;
//						
//						for (int j = 0; j < amountOfVertices; j ++)
//						{
//							if (colors != null && showColors)
//							{
//								glColor4f(colors[0 + colorOffset], colors[1 + colorOffset], colors[2 + colorOffset], colors[3 + colorOffset]);
//							}
//							if (texture != null)
//							{
//								glTexCoord2f(textures[textureOffset], textures[1 + textureOffset]);
//							}
//							if (vertexSize == 3)
//							{
//								glVertex3f(vertices[0 + vertexOffset], vertices[1 + vertexOffset], vertices[2 + vertexOffset]);
//							}
//							else if (vertexSize == 2)
//							{
//								glVertex2f(vertices[0 + vertexOffset], vertices[1 + vertexOffset]);
//							}
//							
//							textureOffset += 2;
//							vertexOffset  += vertexSize;
//							colorOffset   += 4;
//						}
//					}
//					GL11.glEnd();
//				}
//			}
		}

		if (DRAW_MODE_ARRAYS || DRAW_MODE_ELEMENTS)
		{
			if (showColors)
			{
				endColorDraw();
			}
			
			endNormalDraw();
			endVertexDraw();
			endTextureDraw();
		}
	}

	public static void beginVertexDraw(int id, int vertexSize)
	{
		if (id != 0)
		{
			glEnableClientState(GL_VERTEX_ARRAY);
	
			GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, id);

			glVertexPointer(vertexSize, GL11.GL_FLOAT, 0, 0);
		}
	}
	
	/**
	 * Gets the buffer all set for drawing.
	 * 
	 * @param buffer The VerticesBuffer that will be used for drawing.
	 */
	public static void beginVertexDraw(VerticesBuffer buffer)
	{
		glEnableClientState(GL_VERTEX_ARRAY);
		
		if (isUsingVBO())
		{
			buffer.bind();
			
			glVertexPointer(buffer.getVertexSize(), GL11.GL_FLOAT, 0, 0);
			
//			GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);
		}
		else
		{
			glVertexPointer(buffer.getVertexSize(), 0, (FloatBuffer)buffer.getBuffer());
		}
	}
	
	/**
	 * Ends the state of drawing vertices.
	 */
	public static void endVertexDraw()
	{
		glDisableClientState(GL_VERTEX_ARRAY);
	}
	
	public static void beginNormalDraw(int id)
	{
		if (id != 0)
		{
			glEnableClientState(GL_NORMAL_ARRAY);
	
			GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, id);

			glNormalPointer(GL11.GL_FLOAT, 0, 0);
		}
	}
	
	/**
	 * Gets the buffer all set for drawing.
	 * 
	 * @param buffer The LightBuffer that will be used for drawing.
	 */
	public static void beginNormalDraw(LightBuffer buffer)
	{
		glEnableClientState(GL_NORMAL_ARRAY);
		
		if (isUsingVBO())
		{
			buffer.bind();
			
			glNormalPointer(GL11.GL_FLOAT, 0, 0);
//			glNormalPointer(type, stride, pointer_buffer_offset)
			
//			GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);
		}
		else
		{
			glNormalPointer(0, (FloatBuffer)buffer.getBuffer());
		}
	}
	
	public static void endNormalDraw()
	{
		glDisableClientState(GL_NORMAL_ARRAY);
	}
	
	public static void beginColorDraw(int id)
	{
		if (id != 0)
		{
			glEnableClientState(GL_COLOR_ARRAY);
			
			GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, id);

			glColorPointer(4, GL11.GL_FLOAT, 0, 0);
		}
	}
	
	public static void beginColorDraw(LightBuffer buffer)
	{
		glEnableClientState(GL_COLOR_ARRAY);
		
		if (isUsingVBO())
		{
			buffer.bind();
			
			glColorPointer(4, GL11.GL_FLOAT, 0, 0);
			
//			GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);
		}
		else
		{	
			glColorPointer(4, 0, (FloatBuffer)buffer.getBuffer());
		}
	}
	
	public static void endColorDraw()
	{
		glDisableClientState(GL_COLOR_ARRAY);
	}
	
	public static void beginTextureDraw(int id)
	{
		if (id != 0)
		{
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
			
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
			
			glEnableClientState(GL_TEXTURE_COORD_ARRAY);
			
			GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, id);

			glTexCoordPointer(2, GL11.GL_FLOAT, 0, 0);
		}
	}
	
	public static void beginTextureDraw(LightBuffer buffer)
	{
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		
		glEnableClientState(GL_TEXTURE_COORD_ARRAY);
		
		if (isUsingVBO())
		{
			buffer.bind();
			
			glTexCoordPointer(2, GL11.GL_FLOAT, 0, 0);
			
//			GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);
		}
		else
		{	
			glTexCoordPointer(2, 0, (FloatBuffer)buffer.getBuffer());
		}
	}
	
	public static void endTextureDraw()
	{
		glDisableClientState(GL_TEXTURE_COORD_ARRAY);
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	}
	
	public static void setRender3D(boolean render3D)
	{
		GL.render3D = render3D;
		
		initBasicView(0.01f, 999f);
	}
	
	public static void initBasicLights()
	{
		//----------- Variables & method calls added for Lighting Test -----------//
		FloatBuffer matSpecular = BufferUtils.createFloatBuffer(4);
		matSpecular.put(new float[] { 1.0f, 1.0f, 1.0f, 1.0f }).rewind();
		
		FloatBuffer lightPosition = BufferUtils.createFloatBuffer(4);
		lightPosition.put(new float[] { 1.0f, 1.0f, 1.0f, 0.0f }).rewind();
		
		FloatBuffer whiteLight = BufferUtils.createFloatBuffer(4);
		whiteLight.put(new float[] { 1.0f, 1.0f, 1.0f, 1.0f }).rewind();
		
		FloatBuffer lModelAmbient = BufferUtils.createFloatBuffer(4);
		lModelAmbient.put(new float[] { 0.5f, 0.5f, 0.5f, 1.0f }).rewind();
		
//		glShadeModel(GL_SMOOTH);
		glMaterial(GL_FRONT, GL_SPECULAR, matSpecular);				// sets specular material color
		glMaterialf(GL_FRONT, GL_SHININESS, 50.0f);					// sets shininess
		
		glLight(GL_LIGHT0, GL_POSITION, lightPosition);				// sets light position
		glLight(GL_LIGHT0, GL_SPECULAR, whiteLight);				// sets specular light to white
		glLight(GL_LIGHT0, GL_DIFFUSE, whiteLight);					// sets diffuse light to white
		glLightModel(GL_LIGHT_MODEL_AMBIENT, lModelAmbient);		// global ambient light 
		
		glEnable(GL_LIGHTING);										// enables lighting
		glEnable(GL_LIGHT0);										// enables light0
		
		glEnable(GL_COLOR_MATERIAL);								// enables opengl to use glColor3f to define material color
		glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);			// tell opengl glColor3f effects the ambient and diffuse properties of material
		//----------- END: Variables & method calls added for Lighting Test -----------//
	}
	
	public static float getFOV()
	{
		return FOV;
	}
	
	public static void setFOV(float FOV)
	{
		GL.FOV = FOV;
		
		glViewport(0, 0, Display.getWidth(), Display.getHeight());
		glMatrixMode(GL_PROJECTION); // Select The Projection Matrix
		glLoadIdentity(); // Reset The Projection Matrix

		// Calculate The Aspect Ratio Of The Window
		gluPerspective(FOV, (float)Display.getWidth() / (float)Display.getHeight(), zClose, zFar);
//		glOrtho(1, 1, 1, 1, -1, 1);
		glMatrixMode(GL_MODELVIEW); // Select The Modelview Matrix
	}
	
	public static void initBasicView(float zClose, float zFar)
	{
		glPixelStorei(GL11.GL_UNPACK_ALIGNMENT, 1);
		
		GL.zClose = zClose;
		GL.zFar   = zFar;
		
		glEnable(GL_BLEND);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		
		if (render3D)
		{
//			glViewport(0, 0, Display.getWidth(), Display.getHeight());
//			glMatrixMode(GL11.GL_PROJECTION);
//			glLoadIdentity();
//			GLU.gluPerspective(45.0f, ((float) Display.getWidth() / (float) Display.getHeight()), 0.01f, 100.0f);
//			glMatrixMode(GL11.GL_MODELVIEW);
//			glLoadIdentity();
//	
//			glShadeModel(GL11.GL_SMOOTH);
//			glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
//			glClearDepth(1.0f);
//			glEnable(GL11.GL_DEPTH_TEST);
//			glDepthFunc(GL11.GL_LEQUAL);
//			glHint(GL11.GL_PERSPECTIVE_CORRECTION_HINT, GL11.GL_NICEST);
//			
			glEnable(GL11.GL_TEXTURE_2D);
			
//			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
			
//			glEnable(GL_TEXTURE_2D);
			
			glEnable(GL_CULL_FACE);
			
//			glShadeModel(GL_SMOOTH); // Enable Smooth Shading
			glClearColor(0.0f, 0.3f, 0.6f, 0.0f); // Blue Background
			glClearDepth(1.0); // Depth Buffer Setup
			glEnable(GL_DEPTH_TEST); // Enables Depth Testing
			glDepthFunc(GL_LEQUAL); // The Type Of Depth Testing To Do
			
			glViewport(0, 0, Display.getWidth(), Display.getHeight());
			glMatrixMode(GL_PROJECTION); // Select The Projection Matrix
			glLoadIdentity(); // Reset The Projection Matrix
			
			FOV = 55.0f;

			// Calculate The Aspect Ratio Of The Window
			gluPerspective(FOV, (float)Display.getWidth() / (float)Display.getHeight(), zClose, zFar);
//			glOrtho(1, 1, 1, 1, -1, 1);
			glMatrixMode(GL_MODELVIEW); // Select The Modelview Matrix

			// Really Nice Perspective Calculations
			glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
			
			glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);//GL_DECAL);
			
//			GL11.glEnable(GL11.GL_TEXTURE_2D);
//			GL11.glDisable(GL11.GL_TEXTURE_2D);
		}
		else
		{
			glEnable(GL_TEXTURE_2D);
			
//			glBlendFunc(GL_ONE, GL_ONE);
//			GL14.glBlendEquation(GL14.GL_MAX);
			
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
			
			glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
			
			glEnable(GL_BLEND);
			glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
//			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
//			glBlendFunc(GL_DST_COLOR, GL_ONE_MINUS_SRC_ALPHA);
//			glBlendEquation(GL_ADD);
//			GL14.glBlendEquation(GL14.GL_FUNC_ADD);
			
			glEnable(GL_ALPHA_TEST);
			glAlphaFunc(GL_GREATER, 0.1f); 
			
			glEnable(GL_DEPTH_TEST);
			
	//		glEnable(GL_CULL_FACE);
	//		glCullFace(GL_BACK);
			
	//		glShadeModel(GL_SMOOTH); // Enable Smooth Shading
			glClearColor(0.0f, 0.3f, 0.6f, 0.0f); // Blue Background
			
			glViewport(0, 0, Display.getWidth(), Display.getHeight());
			glMatrixMode(GL_PROJECTION); // Select The Projection Matrix
			glLoadIdentity(); // Reset The Projection Matrix
	
			// Calculate The Aspect Ratio Of The Window
			glOrtho(0, Display.getWidth(), 0, Display.getHeight(), -99999, 99999);
			glMatrixMode(GL_MODELVIEW); // Select The Modelview Matrix
		}

		// Really Nice Perspective Calculations
//		glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
		
//		initLighting();
		
		
		
		flipped = false;
	}
	
	public static void drawTexture(Texture texture, float x, float y, float z)
	{
		drawTexture(texture, x, y, z, 1);
	}
	
	public static void drawTexture(Texture texture, float x, float y, float z, float scale)
	{
		drawTexture(texture, x, y, z, scale, LEFT, BOTTOM);
	}
	
	public static void drawTexture(Texture texture, float x, float y, float z, int horizontalAlignment, int verticalAlignment)
	{
		drawTexture(texture, x, y, z, 1, horizontalAlignment, verticalAlignment);
	}
	
	public static void drawTexture(Texture texture, float x, float y, float z, float scale, int horizontalAlignment, int verticalAlignment)
	{
		if (horizontalAlignment == CENTER)
		{
			x += Frame.getCenterX();
			x -= texture.getWidth() * scale / 2;
		}
		else if (horizontalAlignment == RIGHT)
		{
			x += Frame.getWidth();
			x -= texture.getWidth() * scale;
		}
		if (verticalAlignment == CENTER)
		{
			y += Frame.getCenterY();
			y -= texture.getHeight() * scale / 2;
		}
		else if (verticalAlignment == TOP)
		{
			y += Frame.getHeight();
			y -= texture.getHeight() * scale;
		}
		
		GL.pushAttribute(CURRENT_BIT);
		{
			GL.setColorf(1, 1, 1, 1);
			
			texture.bind();
			
			GL.beginManipulation();
			{
				GL.translatef(x, y, z);
				GL.scalef(scale, scale, 1);
				
				float offsets[] = texture.getImageOffsetsf();
				
				GL.glBegin(GL.QUADS);
				{
					GL.glTexCoord2f(offsets[0], offsets[1]);
					GL.glVertex2f(0, 0);
					
					GL.glTexCoord2f(offsets[2], offsets[1]);
					GL.glVertex2f(texture.getWidth(), 0);
					
					GL.glTexCoord2f(offsets[2], offsets[3]);
					GL.glVertex2f(texture.getWidth(), texture.getHeight());
					
					GL.glTexCoord2f(offsets[0], offsets[3]);
					GL.glVertex2f(0, texture.getHeight());
				}
				GL.glEnd();
			}
			GL.endManipulation();
		}
		GL.popAttribute();
	}
	
	public static void loadIdentity()
	{
		glLoadIdentity();
	}
	
	public static void viewOrtho()
	{
		glMatrixMode(GL_PROJECTION); // Select The Projection Matrix
		glLoadIdentity(); // Reset The Projection Matrix

		glOrtho(0, Display.getWidth(), 0, Display.getHeight(), -99999, 99999);
		glMatrixMode(GL_MODELVIEW);
	}
	
	public static void viewPerspective()
	{
		glMatrixMode(GL_PROJECTION); // Select The Projection Matrix
		glLoadIdentity(); // Reset The Projection Matrix

		// Calculate The Aspect Ratio Of The Window
		gluPerspective(FOV, (float)Display.getWidth() / (float)Display.getHeight(), zClose, zFar);
//		glOrtho(1, 1, 1, 1, -1, 1);
		glMatrixMode(GL_MODELVIEW);
	}
	
	public static void resetBasicView()
	{
		glViewport(0, 0, Display.getWidth(), Display.getHeight());
		glMatrixMode(GL_PROJECTION); // Select The Projection Matrix
		glLoadIdentity(); // Reset The Projection Matrix

		// Calculate The Aspect Ratio Of The Window
		gluPerspective(FOV, (float)Display.getWidth() / (float)Display.getHeight(), zClose, zFar);
//		glOrtho(1, 1, 1, 1, -1, 1);
		glMatrixMode(GL_MODELVIEW);
	}
	
	public static void flipView()
	{
		glViewport(0, 0, Display.getWidth(), Display.getHeight());
		glMatrixMode(GL_PROJECTION); // Select The Projection Matrix
		glLoadIdentity(); // Reset The Projection Matrix
		
		if (flipped)
		{
			// Calculate The Aspect Ratio Of The Window
			glOrtho(0, Display.getWidth(), 0, Display.getHeight(), -99999, 99999);
		}
		else
		{
			// Calculate The Aspect Ratio Of The Window
			glOrtho(0, Display.getWidth(), Display.getHeight(), 0, -99999, 99999);
		}
		
		glMatrixMode(GL_MODELVIEW); // Select The Modelview Matrix
		
		flipped = !flipped;
	}
	
	public static void createFrame(int width, int height, String title, Canvas drawCanvas)
	{
		boolean hasCanvas = drawCanvas != null;
		
		try
		{
			Base.includeNatives = true;
			
			if (hasCanvas)
			{
				Display.setParent(drawCanvas);
			}
			
			Display.setDisplayMode(new DisplayMode(width, height));
			
			Display.setTitle(title);
			
			if (!hasCanvas)
			{
				Display.setResizable(true);
			}
			
			Display.setFullscreen(false);
			
			Display.create();
		}
		catch (LWJGLException e)
		{
			e.printStackTrace();
		}
		
//		Display.setVSyncEnabled(false);
	}
	
	public static void createFrame(int width, int height, Canvas drawCanvas)
	{
		createFrame(width, height, "", drawCanvas);
	}
	
	public static float[] addRectColorArrayif(int r, int g, int b, int a, int offset, float[] array)
	{
		if (array == null)
		{
			array = new float[4 * 4];
			
			offset = 0;
		}
		
		int index = 0;
		
		array[offset + index ++] = r / 255f;
		array[offset + index ++] = g / 255f;
		array[offset + index ++] = b / 255f;
		array[offset + index ++] = a / 255f;
		
		array[offset + index ++] = r / 255f;
		array[offset + index ++] = g / 255f;
		array[offset + index ++] = b / 255f;
		array[offset + index ++] = a / 255f;
		
		array[offset + index ++] = r / 255f;
		array[offset + index ++] = g / 255f;
		array[offset + index ++] = b / 255f;
		array[offset + index ++] = a / 255f;
		
		array[offset + index ++] = r / 255f;
		array[offset + index ++] = g / 255f;
		array[offset + index ++] = b / 255f;
		array[offset + index ++] = a / 255f;
		
		return array;
	}
	
	public static float[] addCubeColorArrayif(int r, int g, int b, int a, int offset, float[] array)
	{
		if (array == null)
		{
			array = new float[4 * 4 * 6];
			
			offset = 0;
		}
		
		int index = 0;
		
		for (int i = 0; i < 6; i ++)
		{
			addRectColorArrayif(r, g, b, a, i * 4 * 4, array);
		}
		
		return array;
	}
	
	public static float[] addCubeColorArrayf(int colors[][], int offset, float[] array)
	{
		if (array == null)
		{
			array  = new float[4 * 4 * 6];
			
			offset = 0;
		}
		
		int index   = 0;
		
		int leftOff = 0;
		
		for (leftOff = 0; leftOff < colors.length; leftOff ++)
		{
			array[offset + index ++] = colors[leftOff][0];
			array[offset + index ++] = colors[leftOff][1];
			array[offset + index ++] = colors[leftOff][2];
			array[offset + index ++] = colors[leftOff][3];
			
			array[offset + index ++] = colors[leftOff][0];
			array[offset + index ++] = colors[leftOff][1];
			array[offset + index ++] = colors[leftOff][2];
			array[offset + index ++] = colors[leftOff][3];
			
			array[offset + index ++] = colors[leftOff][0];
			array[offset + index ++] = colors[leftOff][1];
			array[offset + index ++] = colors[leftOff][2];
			array[offset + index ++] = colors[leftOff][3];
			
			array[offset + index ++] = colors[leftOff][0];
			array[offset + index ++] = colors[leftOff][1];
			array[offset + index ++] = colors[leftOff][2];
			array[offset + index ++] = colors[leftOff][3];
		}
		
		leftOff --;
		
		for (int i = leftOff + 1; i < 6; i ++)
		{
			array[offset + index ++] = colors[leftOff][0];
			array[offset + index ++] = colors[leftOff][1];
			array[offset + index ++] = colors[leftOff][2];
			array[offset + index ++] = colors[leftOff][3];
			
			array[offset + index ++] = colors[leftOff][0];
			array[offset + index ++] = colors[leftOff][1];
			array[offset + index ++] = colors[leftOff][2];
			array[offset + index ++] = colors[leftOff][3];
			
			array[offset + index ++] = colors[leftOff][0];
			array[offset + index ++] = colors[leftOff][1];
			array[offset + index ++] = colors[leftOff][2];
			array[offset + index ++] = colors[leftOff][3];
			
			array[offset + index ++] = colors[leftOff][0];
			array[offset + index ++] = colors[leftOff][1];
			array[offset + index ++] = colors[leftOff][2];
			array[offset + index ++] = colors[leftOff][3];
		}
		
		return array;
	}
	
	public static float[] addCubeColorArrayif(int colors[][], int offset, float[] array)
	{
		if (array == null)
		{
			array  = new float[4 * 4 * 6];
			
			offset = 0;
		}
		
		int index   = 0;
		
		int leftOff = 0;
		
		for (leftOff = 0; leftOff < colors.length; leftOff ++)
		{
			array[offset + index ++] = colors[leftOff][0] / 255f;
			array[offset + index ++] = colors[leftOff][1] / 255f;
			array[offset + index ++] = colors[leftOff][2] / 255f;
			array[offset + index ++] = colors[leftOff][3] / 255f;
			
			array[offset + index ++] = colors[leftOff][0] / 255f;
			array[offset + index ++] = colors[leftOff][1] / 255f;
			array[offset + index ++] = colors[leftOff][2] / 255f;
			array[offset + index ++] = colors[leftOff][3] / 255f;
			
			array[offset + index ++] = colors[leftOff][0] / 255f;
			array[offset + index ++] = colors[leftOff][1] / 255f;
			array[offset + index ++] = colors[leftOff][2] / 255f;
			array[offset + index ++] = colors[leftOff][3] / 255f;
			
			array[offset + index ++] = colors[leftOff][0] / 255f;
			array[offset + index ++] = colors[leftOff][1] / 255f;
			array[offset + index ++] = colors[leftOff][2] / 255f;
			array[offset + index ++] = colors[leftOff][3] / 255f;
		}
		
		leftOff --;
		
		for (int i = leftOff + 1; i < 6; i ++)
		{
			array[offset + index ++] = colors[leftOff][0] / 255f;
			array[offset + index ++] = colors[leftOff][1] / 255f;
			array[offset + index ++] = colors[leftOff][2] / 255f;
			array[offset + index ++] = colors[leftOff][3] / 255f;
			
			array[offset + index ++] = colors[leftOff][0] / 255f;
			array[offset + index ++] = colors[leftOff][1] / 255f;
			array[offset + index ++] = colors[leftOff][2] / 255f;
			array[offset + index ++] = colors[leftOff][3] / 255f;
			
			array[offset + index ++] = colors[leftOff][0] / 255f;
			array[offset + index ++] = colors[leftOff][1] / 255f;
			array[offset + index ++] = colors[leftOff][2] / 255f;
			array[offset + index ++] = colors[leftOff][3] / 255f;
			
			array[offset + index ++] = colors[leftOff][0] / 255f;
			array[offset + index ++] = colors[leftOff][1] / 255f;
			array[offset + index ++] = colors[leftOff][2] / 255f;
			array[offset + index ++] = colors[leftOff][3] / 255f;
		}
		
		return array;
	}
	
	public static double[] addRectColorArrayid(int r, int g, int b, int a, int offset, double[] array)
	{
		if (array == null)
		{
			array = new double[4 * 4];
			
			offset = 0;
		}
		
		int index = 0;
		
		array[offset + index ++] = r / 255f;
		array[offset + index ++] = g / 255f;
		array[offset + index ++] = b / 255f;
		array[offset + index ++] = a / 255f;
		
		array[offset + index ++] = r / 255f;
		array[offset + index ++] = g / 255f;
		array[offset + index ++] = b / 255f;
		array[offset + index ++] = a / 255f;
		
		array[offset + index ++] = r / 255f;
		array[offset + index ++] = g / 255f;
		array[offset + index ++] = b / 255f;
		array[offset + index ++] = a / 255f;
		
		array[offset + index ++] = r / 255f;
		array[offset + index ++] = g / 255f;
		array[offset + index ++] = b / 255f;
		array[offset + index ++] = a / 255f;
		
		return array;
	}
	
	public static float[] addRectColorArrayf(float r, float g, float b, float a, int offset, float[] array)
	{
		if (array == null)
		{
			array = new float[4 * 4];
			
			offset = 0;
		}
		
		int index = 0;
		
		array[offset + index ++] = r;
		array[offset + index ++] = g;
		array[offset + index ++] = b;
		array[offset + index ++] = a;
		
		array[offset + index ++] = r;
		array[offset + index ++] = g;
		array[offset + index ++] = b;
		array[offset + index ++] = a;
		
		array[offset + index ++] = r;
		array[offset + index ++] = g;
		array[offset + index ++] = b;
		array[offset + index ++] = a;
		
		array[offset + index ++] = r;
		array[offset + index ++] = g;
		array[offset + index ++] = b;
		array[offset + index ++] = a;
		
		return array;
	}
	
	public static float[] addCubeTextureArrayf(Texture texture, int offset, float array[])
	{
		return addCubeTextureArrayf(texture.getImageOffsetsf(), offset, array);
	}
	
	public static float[] addCubeTextureArrayf(SpriteSheet sprites, int x, int y, int w, int h, int offset, float array[])
	{
		return addCubeTextureArrayf(sprites.getImageOffsetsf(x, y, w, h), offset, array);
	}
	
	public static float[] addCubeTextureArrayf(float offsets[], int offset, float array[])
	{
		return addCubeTextureArrayf(new float[][] { offsets }, offset, array);
	}
	
	public static float[] addCubeTextureArrayf(float offsets[][], int offset, float array[])
	{
		return addCubeTextureArrayf(offsets, 1, 1, offset, array);
	}
	
	public static float[] addCubeTextureArrayf(float offsets[][], int rx, int ry, int offset, float array[])
	{
		if (array == null)
		{
			array    = new float[2 * 4 * 6];
			
			offset   = 0;
		}
		
		int index    = 0;
		
		int leftOff  = 0;
		
		for (leftOff = 0; leftOff < offsets.length; leftOff ++)
		{
			array[offset + index ++] = rx * offsets[leftOff][0];
			array[offset + index ++] = ry * offsets[leftOff][1];
			
			array[offset + index ++] = rx * offsets[leftOff][2];
			array[offset + index ++] = ry * offsets[leftOff][1];
			
			array[offset + index ++] = rx * offsets[leftOff][2];
			array[offset + index ++] = ry * offsets[leftOff][3];
			
			array[offset + index ++] = rx * offsets[leftOff][0];
			array[offset + index ++] = ry * offsets[leftOff][3];
		}
		
		leftOff --;
		
		for (int i = leftOff + 1; i < 6; i ++)
		{
			array[offset + index ++] = rx * offsets[leftOff][0];
			array[offset + index ++] = ry * offsets[leftOff][1];
			
			array[offset + index ++] = rx * offsets[leftOff][2];
			array[offset + index ++] = ry * offsets[leftOff][1];
			
			array[offset + index ++] = rx * offsets[leftOff][2];
			array[offset + index ++] = ry * offsets[leftOff][3];
			
			array[offset + index ++] = rx * offsets[leftOff][0];
			array[offset + index ++] = ry * offsets[leftOff][3];
		}
		
		return array;
	}
	
	public static float[] addCubeVertexArrayf(float x, float y, float z, float width, float height, float depth, int offset, float array[])
	{
		if (array == null)
		{
			array  = new float[3 * 4 * 6];
			
			offset = 0;
		}
		
		int index = 0;
		
		// Front
		array[offset + index ++] = x + width;
		array[offset + index ++] = y;
		array[offset + index ++] = z;
		
		array[offset + index ++] = x;
		array[offset + index ++] = y;
		array[offset + index ++] = z;
		
		array[offset + index ++] = x;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z;
		
		array[offset + index ++] = x + width;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z;
		
		
		// Right
		array[offset + index ++] = x + width;
		array[offset + index ++] = y;
		array[offset + index ++] = z + depth;
		
		array[offset + index ++] = x + width;
		array[offset + index ++] = y;
		array[offset + index ++] = z;
		
		array[offset + index ++] = x + width;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z;
		
		array[offset + index ++] = x + width;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z + depth;
		
		
		// Back
		array[offset + index ++] = x;
		array[offset + index ++] = y;
		array[offset + index ++] = z + depth;
		
		array[offset + index ++] = x + width;
		array[offset + index ++] = y;
		array[offset + index ++] = z + depth;
		
		array[offset + index ++] = x + width;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z + depth;
		
		array[offset + index ++] = x;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z + depth;
		
		
		// Left
		array[offset + index ++] = x;
		array[offset + index ++] = y;
		array[offset + index ++] = z;
		
		array[offset + index ++] = x;
		array[offset + index ++] = y;
		array[offset + index ++] = z + depth;
		
		array[offset + index ++] = x;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z + depth;
		
		array[offset + index ++] = x;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z;
		
		
		// Top
		array[offset + index ++] = x + width;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z;
		
		array[offset + index ++] = x;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z;
		
		array[offset + index ++] = x;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z + depth;
		
		array[offset + index ++] = x + width;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z + depth;
		
		
		// Bottom
		array[offset + index ++] = x;
		array[offset + index ++] = y;
		array[offset + index ++] = z + depth;
		
		array[offset + index ++] = x;
		array[offset + index ++] = y;
		array[offset + index ++] = z;
		
		array[offset + index ++] = x + width;
		array[offset + index ++] = y;
		array[offset + index ++] = z;
		
		array[offset + index ++] = x + width;
		array[offset + index ++] = y;
		array[offset + index ++] = z + depth;
		
		return array;
	}
	
	public static float[] addCubeNormalArrayf(int offset, float array[])
	{
		if (array == null)
		{
			array  = new float[3 * 4 * 6];
			
			offset = 0;
		}
		
		int index = 0;
		
		// Front
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		array[offset + index ++] = -1;
		
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		array[offset + index ++] = -1;
		
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		array[offset + index ++] = -1;
		
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		array[offset + index ++] = -1;
		
		
		// Right
		array[offset + index ++] = 1;
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;

		array[offset + index ++] = 1;
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;

		array[offset + index ++] = 1;
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;

		array[offset + index ++] = 1;
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		
		
		// Back
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		array[offset + index ++] = 1;

		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		array[offset + index ++] = 1;

		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		array[offset + index ++] = 1;

		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		array[offset + index ++] = 1;
		
		
		// Left
		array[offset + index ++] = -1;
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;

		array[offset + index ++] = -1;
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;

		array[offset + index ++] = -1;
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;

		array[offset + index ++] = -1;
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		
		
		// Top
		array[offset + index ++] = 0;
		array[offset + index ++] = 1;
		array[offset + index ++] = 0;

		array[offset + index ++] = 0;
		array[offset + index ++] = 1;
		array[offset + index ++] = 0;

		array[offset + index ++] = 0;
		array[offset + index ++] = 1;
		array[offset + index ++] = 0;

		array[offset + index ++] = 0;
		array[offset + index ++] = 1;
		array[offset + index ++] = 0;
		
		
		// Bottom
		array[offset + index ++] = 0;
		array[offset + index ++] = -1;
		array[offset + index ++] = 0;

		array[offset + index ++] = 0;
		array[offset + index ++] = -1;
		array[offset + index ++] = 0;

		array[offset + index ++] = 0;
		array[offset + index ++] = -1;
		array[offset + index ++] = 0;

		array[offset + index ++] = 0;
		array[offset + index ++] = -1;
		array[offset + index ++] = 0;
		
		return array;
	}
	
	public static float[] addCubeVertexArrayf(float vertices[], float depth, int offset, float array[])
	{
		if (array == null)
		{
			array  = new float[3 * 4 * 6];

			offset = 0;
		}

		double depthVsWidth     = (double)depth / (vertices[3 * 3 + 0] - vertices[3 * 0 + 0]);
		double depthVsHeight    = (double)depth / (vertices[3 * 1 + 1] - vertices[3 * 0 + 1]);
		
		float rightSideYOffset  = (float)((vertices[3 * 3 + 2] - vertices[3 * 2 + 2]) * depthVsHeight);
		float leftSideYOffset   = (float)((vertices[3 * 0 + 2] - vertices[3 * 1 + 2]) * depthVsHeight);
//		rightSideYOffset       += (float)((vertices[3 * 0 + 1] - vertices[3 * 3 + 1]) * depthVsHeight);
//		leftSideYOffset        += (float)((vertices[3 * 1 + 1] - vertices[3 * 2 + 1]) * depthVsHeight);
		float bottomSideXOffset = (float)((vertices[3 * 0 + 2] - vertices[3 * 3 + 2]) * depthVsWidth);
		float topSideXOffset    = (float)((vertices[3 * 1 + 2] - vertices[3 * 2 + 2]) * depthVsWidth);
//		bottomSideXOffset      += (float)((vertices[3 * 0 + 1] - vertices[3 * 3 + 1]) * depthVsWidth);
//		topSideXOffset         += (float)((vertices[3 * 1 + 1] - vertices[3 * 2 + 1]) * depthVsWidth);
		
		int index = 0;

		// Front
		array[offset + index ++] = vertices[3 * 0 + 0];
		array[offset + index ++] = vertices[3 * 0 + 1];
		array[offset + index ++] = vertices[3 * 0 + 2];

		array[offset + index ++] = vertices[3 * 1 + 0];
		array[offset + index ++] = vertices[3 * 1 + 1];
		array[offset + index ++] = vertices[3 * 1 + 2];

		array[offset + index ++] = vertices[3 * 2 + 0];
		array[offset + index ++] = vertices[3 * 2 + 1];
		array[offset + index ++] = vertices[3 * 2 + 2];

		array[offset + index ++] = vertices[3 * 3 + 0];
		array[offset + index ++] = vertices[3 * 3 + 1];
		array[offset + index ++] = vertices[3 * 3 + 2];


		// Right
		array[offset + index ++] = vertices[3 * 3 + 0];
		array[offset + index ++] = vertices[3 * 3 + 1];
		array[offset + index ++] = vertices[3 * 3 + 2];

		array[offset + index ++] = vertices[3 * 2 + 0];
		array[offset + index ++] = vertices[3 * 2 + 1];
		array[offset + index ++] = vertices[3 * 2 + 2];

		array[offset + index ++] = vertices[3 * 2 + 0] + topSideXOffset;
		array[offset + index ++] = vertices[3 * 2 + 1] + rightSideYOffset;
		array[offset + index ++] = vertices[3 * 2 + 2] + depth;

		array[offset + index ++] = vertices[3 * 3 + 0] + bottomSideXOffset;
		array[offset + index ++] = vertices[3 * 3 + 1] + rightSideYOffset;
		array[offset + index ++] = vertices[3 * 3 + 2] + depth;

		// Back
		array[offset + index ++] = vertices[3 * 3 + 0] + bottomSideXOffset;
		array[offset + index ++] = vertices[3 * 3 + 1] + rightSideYOffset;
		array[offset + index ++] = vertices[3 * 3 + 2] + depth;

		array[offset + index ++] = vertices[3 * 2 + 0] + topSideXOffset;
		array[offset + index ++] = vertices[3 * 2 + 1] + rightSideYOffset;
		array[offset + index ++] = vertices[3 * 2 + 2] + depth;

		array[offset + index ++] = vertices[3 * 1 + 0] + topSideXOffset;
		array[offset + index ++] = vertices[3 * 1 + 1] + leftSideYOffset;
		array[offset + index ++] = vertices[3 * 1 + 2] + depth;

		array[offset + index ++] = vertices[3 * 0 + 0] + bottomSideXOffset;
		array[offset + index ++] = vertices[3 * 0 + 1] + leftSideYOffset;
		array[offset + index ++] = vertices[3 * 0 + 2] + depth;


		// Left
		array[offset + index ++] = vertices[3 * 0 + 0] + bottomSideXOffset;
		array[offset + index ++] = vertices[3 * 0 + 1] + leftSideYOffset;
		array[offset + index ++] = vertices[3 * 0 + 2] + depth;

		array[offset + index ++] = vertices[3 * 1 + 0] + topSideXOffset;
		array[offset + index ++] = vertices[3 * 1 + 1] + leftSideYOffset;
		array[offset + index ++] = vertices[3 * 1 + 2] + depth;
		
		array[offset + index ++] = vertices[3 * 1 + 0];
		array[offset + index ++] = vertices[3 * 1 + 1];
		array[offset + index ++] = vertices[3 * 1 + 2];

		array[offset + index ++] = vertices[3 * 0 + 0];
		array[offset + index ++] = vertices[3 * 0 + 1];
		array[offset + index ++] = vertices[3 * 0 + 2];


		// Top
		array[offset + index ++] = vertices[3 * 1 + 0];
		array[offset + index ++] = vertices[3 * 1 + 1];
		array[offset + index ++] = vertices[3 * 1 + 2];

		array[offset + index ++] = vertices[3 * 1 + 0] + topSideXOffset;
		array[offset + index ++] = vertices[3 * 1 + 1] + leftSideYOffset;
		array[offset + index ++] = vertices[3 * 1 + 2] + depth;

		array[offset + index ++] = vertices[3 * 2 + 0] + topSideXOffset;
		array[offset + index ++] = vertices[3 * 2 + 1] + rightSideYOffset;
		array[offset + index ++] = vertices[3 * 2 + 2] + depth;

		array[offset + index ++] = vertices[3 * 2 + 0];
		array[offset + index ++] = vertices[3 * 2 + 1];
		array[offset + index ++] = vertices[3 * 2 + 2];


		// Bottom
		array[offset + index ++] = vertices[3 * 0 + 0] + bottomSideXOffset;
		array[offset + index ++] = vertices[3 * 0 + 1] + rightSideYOffset;
		array[offset + index ++] = vertices[3 * 0 + 2] + depth;

		array[offset + index ++] = vertices[3 * 0 + 0];
		array[offset + index ++] = vertices[3 * 0 + 1];
		array[offset + index ++] = vertices[3 * 0 + 2];

		array[offset + index ++] = vertices[3 * 3 + 0];
		array[offset + index ++] = vertices[3 * 3 + 1];
		array[offset + index ++] = vertices[3 * 3 + 2];

		array[offset + index ++] = vertices[3 * 3 + 0] + bottomSideXOffset;
		array[offset + index ++] = vertices[3 * 3 + 1] + leftSideYOffset;
		array[offset + index ++] = vertices[3 * 3 + 2] + depth;

		return array;
	}
	
	public static float[] addRectVertexArrayf(float x, float y, float z, float width, float height, int offset, float array[])
	{
		if (array == null)
		{
			array  = new float[3 * 4];
			
			offset = 0;
		}
		
		int index = 0;
		
		array[offset + index ++] = x;
		array[offset + index ++] = y;
		array[offset + index ++] = z;
		
		array[offset + index ++] = x;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z;
		
		array[offset + index ++] = x + width;
		array[offset + index ++] = y + height;
		array[offset + index ++] = z;
		
		array[offset + index ++] = x + width;
		array[offset + index ++] = y;
		array[offset + index ++] = z;
		
		return array;
	}
	
	public static float[] addRectVertexArrayf(float x, float y, float width, float height, int offset, float[] array)
	{
		if (array == null)
		{
			array = new float[2 * 4];
			
			offset = 0;
		}
		
		int index = 0;

		array[offset + index ++] = x;
		array[offset + index ++] = y;
		
		array[offset + index ++] = x + width + width / 100;
		array[offset + index ++] = y;
		
		array[offset + index ++] = x + width + width / 100;
		array[offset + index ++] = y + height + height / 100;
		
		array[offset + index ++] = x;
		array[offset + index ++] = y + height + height / 100;
		
		return array;
	}
	
	public static float[] addRectTextureArrayf(SpriteSheet spriteSheet, int x, int y, int width, int height, int offset, float[] array)
	{
		return addRectTextureArrayf(spriteSheet.getImageOffsetsf(x, y, width, height), offset, array);
	}
	
	public static float[] addRectTextureArrayf(Texture texture, int offset, float[] array)
	{
		return addRectTextureArrayf(texture.getImageOffsetsf(), offset, array);
	}
	
	public static float[] addRectTextureArrayf(Texture texture, int offset, float[] array, boolean mirrorHorizontal, boolean mirrorVertical)
	{
		return addRectTextureArrayf(texture.getImageOffsetsf(), offset, array, mirrorHorizontal, mirrorVertical);
	}
	
	public static float[] addRectTextureArrayf(float offsets[], int offset, float[] array)
	{
		return addRectTextureArrayf(offsets, offset, array, false, false);
	}
	
	public static float[] addRectTextureArrayf(float offsets[], int rx, int ry, int offset, float[] array)
	{
		return addRectTextureArrayf(offsets, rx, ry, offset, array, false, false);
	}
	
	public static float[] addRectTextureArrayf(float offsets[], int offset, float[] array, boolean mirrorHorizontal, boolean mirrorVertical)
	{
		return addRectTextureArrayf(offsets, 1, 1, offset, array, mirrorHorizontal, mirrorVertical);
	}
	
	public static float[] addRectTextureArrayf(float offsets[], int rx, int ry, int offset, float[] array, boolean mirrorHorizontal, boolean mirrorVertical)
	{
		if (array == null)
		{
			array = new float[2 * 4];
			
			offset = 0;
		}
		
		int index = 0;
		
		if (mirrorHorizontal)
		{
			array[0] = rx * offsets[0];
			
			array[2] = rx * offsets[0];
			
			array[4] = rx * offsets[2];

			array[6] = rx * offsets[2];
		}
		else
		{
			array[0] = rx * offsets[0];
			
			array[2] = rx * offsets[2];
			
			array[4] = rx * offsets[2];
			
			array[6] = rx * offsets[0];
		}
		
		if (mirrorVertical)
		{
			array[1] = ry * offsets[3];
			
			array[3] = ry * offsets[1];
			
			array[5] = ry * offsets[1];	

			array[7] = ry * offsets[3];
		}
		else
		{
			array[1] = ry * offsets[1];
			
			array[3] = ry * offsets[1];
			
			array[5] = ry * offsets[3];
			
			array[7] = ry * offsets[3];
		}
		
		return array;
	}
	
	public static float[] addRectNormalArrayf(int z, int offset, float[] array)
	{
		if (array == null)
		{
			array = new float[3 * 4];
			
			offset = 0;
		}
		
		int index = 0;
		
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		array[offset + index ++] = z;
		
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		array[offset + index ++] = z;
		
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		array[offset + index ++] = z;
		
		array[offset + index ++] = 0;
		array[offset + index ++] = 0;
		array[offset + index ++] = z;
		
		return array;
	}
}
